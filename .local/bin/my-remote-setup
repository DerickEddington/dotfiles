#! /usr/bin/env bash
set -o errexit -o nounset
shopt -s assoc_expand_once extglob
(( "${VERBOSE:=0}" >= 3 )) && set -o xtrace
(( "${VERBOSE:=0}" >= 4 )) && set -o verbose


# Capture arguments, before anything else could mess with them.

self=$(basename "$0") ; readonly self

(( $# == 1 )) || {
    echo "Usage: $self ssh://[USER@]HOSTNAME[:PORT]"
    echo "   or: $self vagrant://[NAME|ID]"
    exit 1
} 1>&2

readonly remoteUrl=$1


# shellcheck source=../share/my/bash/helpers.bash
source "${XDG_DATA_HOME:-$HOME/.local/share}"/my/bash/helpers.bash


# Functions

function process-vars {
    process-args
    process-env-vars
}

function process-args
{
    if [[ "$remoteUrl" =~ ^ssh://[^/]+$ ]]
    then
        readonly remoteID=$remoteUrl
        local sshOptsExtra=(
            -T  # `-T` to separate stdout & stderr.
        )
        if (( "$VERBOSE" >= 5 )); then
            local i
            for (( i = VERBOSE - 4 ; i > 0 ; i-- )); do
                sshOptsExtra+=(-v)
            done
        fi
        readonly remoteCmd=(ssh "${sshOptsExtra[@]}" "$remoteID")
        readonly remoteDotfilesRepoUrl=$remoteUrl/~/.dotfiles

    elif [[ "$remoteUrl" =~ ^vagrant://([^/]+)$ ]]
    then
        readonly remoteID=${BASH_REMATCH[1]}
        readonly remoteCmd=(vagrant-ssh-coalesce-cmd "$remoteID")
        # Enables accessing remote Git repo over `vagrant ssh` command (instead of trying to
        # construct `scp ...` or `ssh://...` from `vagrant ssh-config` output).
        # shellcheck disable=SC2016
        readonly remoteDotfilesRepoUrl='ext::vagrant-ssh-coalesce-cmd '"$remoteID"' %S $HOME/.dotfiles'
    else
        fail "Unsupported URL: ${remoteUrl@Q}"
    fi
}

function process-env-vars
{
    localDotfilesRepo=${MY_REMOTE_SETUP_DOTFILES_FROM_REPO:-$HOME/.dotfiles}
    if ! [[ "$localDotfilesRepo" = */@(.git|.dotfiles) ]]; then
        localDotfilesRepo+=/.git
    fi
    localDotfilesRepo=$(gnu realpath -m -L -s "$localDotfilesRepo") || return

    remoteUser=$(rshc 'logname') || return
    pushRefSpecs=${MY_REMOTE_SETUP_DOTFILES_FROM_REFSPECS:-HEAD:user/$remoteUser main}
    split-on-words "$pushRefSpecs" pushRefSpecs

    remoteUserBranch=${pushRefSpecs[0]#*:}  # The first refspec is considered the primary.

    declare -g -A gitVerbosity
    if (( VERBOSE == 0 )); then
        gitVerbosity=(
              [branch]=--quiet
            [checkout]=--quiet
              [commit]=--quiet
               [fetch]=--quiet
                [init]=--quiet
               [merge]=--quiet
                [push]=--quiet
               [reset]=--quiet
        )
    elif (( VERBOSE == 1 )); then
        gitVerbosity=(
            [merge]=--stat
        )
    elif (( VERBOSE >= 2 )); then
        gitVerbosity=(
              [add]=--verbose
            [fetch]=--verbose
            [merge]='--verbose --stat'
             [push]=--verbose
        )
    fi

    readonly localDotfilesRepo remoteUser pushRefSpecs remoteUserBranch gitVerbosity
}

function failed-to {
    fail "Failed to $1 in ${remoteUrl@Q}!" "${@:2}"
}

function failed-to-dotfiles {
    failed-to "$1 ~/.dotfiles repository" "${@:2}"
}

function rshc {
    (( $# == 1 ))  # Else: errexit.
    local shOptsExtra=()
    if (( VERBOSE >= 3 )); then shOptsExtra+=('set -x; '); fi
    if (( VERBOSE >= 4 )); then shOptsExtra+=('set -v; '); fi

    "${remoteCmd[@]}" "/bin/sh -c '${shOptsExtra[*]}'${1@Q}"
}

function rshc-in-home {
    local -r origIFS=$IFS; IFS=$'\n'; local -r cmds="$*"; IFS=$origIFS
    # shellcheck disable=SC2016
    rshc $'(set -e; cd "$HOME";\n'"$cmds"')'
}

function has-dotfiles {
    # shellcheck disable=SC2016
    rshc '[ -e "$HOME"/.dotfiles ]'
}

function has-command {
    rshc "command -v ${1@Q} > /dev/null 2>&1"
}
function has-git { has-command git ;}
function has-bash { has-command bash ;}

function todo {
    error "TODO: Need support for: ${1}."
    return 2
}

function install-pkg {
    local pkg=$1 os cmd
    os=$(rshc 'uname') || return

    case "$os" in
        (Linux)
            local variant
            variant=$(rshc 'lsb_release -s -i') || return
            case "$variant" in
                (Ubuntu)
                    cmd="sudo apt-get install --yes ${pkg@Q}"
                    ;;
                (*)
                    todo "Linux variant: ${variant@Q}"
                    return
                    ;;
            esac
            ;;
        (FreeBSD)
            cmd="sudo pkg install --yes ${pkg@Q}"
            ;;
        (SunOS)
            cmd="sudo pkg install ${pkg@Q}"  # TODO: whatever for automatic "yes"
            ;;
        (*)
            todo "OS: ${os@Q}"
            return
            ;;
    esac

    rshc "$cmd"
}
function install-git { install-pkg git ;}
function install-bash { install-pkg bash ;}

function start-dotfiles-repo {
    local -r vi=${gitVerbosity[init]:-} va=${gitVerbosity[add]:-} vc=${gitVerbosity[commit]:-}
    # shellcheck disable=SC2016
    rshc-in-home '
        git init '"$vi"' --initial-branch=preexisting .
        git add '"$va"' --ignore-errors .
        git init '"$vi"' --separate-git-dir=.dotfiles .  # After, to avoid tracking .dotfiles/.
        git config user.name "$(logname)"
        git config user.email "$(logname)@$(uname -n)"
        if git status --porcelain | grep -q -E -e "^A " ; then
            git commit '"$vc"' --message="As was."
        else
            : # Nothing was added, so, to avoid error, do not try to commit.
        fi
    '
}

function push-to-dotfiles-repo {
    # shellcheck disable=SC2206
    local -r vp=(${gitVerbosity[push]:-})

    # Use --git-dir, instead of -C, so that `git` does not change its current working directory,
    # which is needed for correct functioning of aspects like `vagrant ssh $MACHINE_NAME` as
    # invoked via `ext::...` URLs.
    #
    git --git-dir="$localDotfilesRepo" -c protocol.ext.allow=always \
        push "${vp[@]}" --follow-tags "$remoteDotfilesRepoUrl" "${pushRefSpecs[@]}"
}

function merge-dotfiles {
    local -r vc=${gitVerbosity[checkout]:-} vm=${gitVerbosity[merge]:-} vf=${gitVerbosity[fetch]:-} \
             vb=${gitVerbosity[branch]:-}
    # shellcheck disable=SC2016
    rshc-in-home '
        export GIT_DIR=.dotfiles
        mergeBranch=merge-dotfiles-into-$(git branch --show-current)

        git checkout '"$vc"' -b "$mergeBranch"

        if git merge '"$vm"' --allow-unrelated-histories --no-edit '"${remoteUserBranch@Q}"'
        then
            git fetch '"$vf"' --no-write-fetch-head . "$mergeBranch":'"${remoteUserBranch@Q}"'
            git checkout '"$vc"' '"${remoteUserBranch@Q}"'
            git branch '"$vb"' --delete --force "$mergeBranch"
        else
            git merge --abort
            # Leave the $mergeBranch for the user to manually do the merge.
            exit 6
        fi
    '
}

function hide-dotfiles-gitdir {
    rshc 'mv .git .git-hidden'
}

function setup-dotfiles
{
    local retCode=0

    # Check if we don't need to do anything.  Doing nothing is critical for being idempotent when
    # this script is applied to the same host multiple times (e.g. via a `vagrant up` trigger).
    #
    has-dotfiles && {
        echo "Info: Already has ~/.dotfiles in ${remoteUrl@Q}. Doing nothing."
        return 0  #  Considered a success.
    }

    # Install Git if not already
    #
    has-git || {
        install-git || fail "Failed to install Git!" 3
    }

    # Create ~/.dotfiles repository, and track all preexisting files in ~/ in their own separate
    # branch.
    #
    start-dotfiles-repo || failed-to-dotfiles "start" 4

    # Push host user's designated branch
    #
    push-to-dotfiles-repo || failed-to-dotfiles "push to" 5

    # Merge the `preexisting` branch with the user's dotfiles branch, while keeping the
    # preexisting files checked-out.  Done this way so that ~/.ssh/authorized_keys never goes
    # missing and so that it retains whatever key(s) were originally provisioned, to prevent the
    # possibility of breaking SSH access even once briefly.  When this succeeds, the user's branch
    # is checked-out in the remote ~/.
    #
    merge-dotfiles || {
        warn "Failed to merge ${remoteUserBranch@Q} with preexisting! You should manually do."
        retCode=7
    }

    # Hide ~/.git so that the user's home directory is not seen by Git as a repository most of the
    # time.
    #
    hide-dotfiles-gitdir || failed-to-dotfiles "hide git-dir of" 8

    return $retCode
}

function change-gitignore {
    local -r hmComment='# Things managed by home-manager'

    if rshc-in-home 'grep -q -F -e '"${hmComment@Q}"' .gitignore'
    then
        # This deletes (d) all lines starting from the comment one to the end of file ($).
        local -r sedScript="/$hmComment/,\$d"
        rshc-in-home '
            sed -e '"${sedScript@Q}"' .gitignore > .gitignore-changed
            mv .gitignore-changed .gitignore
        '
    fi
}

function setup-home
{
    setup-dotfiles || warn "Failed to setup ~/.dotfiles completely."

    # Change .gitignore to not ignore files that are of interest in the remote home.
    #
    change-gitignore || warn 'Failed to change .gitignore.'

    # Ensure permissions on and in ~/ are good
    #
    # shellcheck disable=SC2016
    rshc-in-home '
        chmod o-rwx .
        chmod -R go-rwx .ssh
    ' || warn 'Failed to chmod something(s) in ~/.'

    # Stage any of the changes to ~/ resulting from the above.
    #
    stage-changes-in-home "at end of setup-home" || true
}

function stage-changes-in-home {
    local va=${gitVerbosity[add]:-}

    rshc-in-home 'git --git-dir=.dotfiles add '"$va"' --all --ignore-errors' || {
        warn "Failed to stage changes to ~/${1:+ $1}."
        return 11
    }
}

function setup-packages
{
    # Install Bash if not already
    #
    has-bash || {
        install-bash || fail "Failed to install Bash!" 9
    }

    # Install the packages that are specified by the user's configuration.
    #
    # shellcheck disable=SC2016
    rshc '(set -e
        cd "${TMPDIR:-/tmp}"  # Not needed, but might as well.

        XDG_DATA_HOME=$HOME/.local/share                            \
        XDG_CONFIG_HOME=$HOME/.config                               \
        VERBOSE='"${VERBOSE@Q}"'                                    \
            $HOME/.local/share/my/platform/install-desired-packages
    )' || {
        error "Failed to install-desired-packages."
        return 10
    }

    # Stage any changes to ~/ resulting from the above installing.  (E.g. `cargo install` might
    # add/update its metadata files.)
    #
    stage-changes-in-home "after install-desired-packages" || true
}

# shellcheck disable=SC2016
function setup-login
{
    # Make user's login shell be Bash, if not already
    #
    rshc 'sudo chsh -s $(command -v bash) $(logname)'  # TODO: Portable enough?

    # Include user's shell-init customizations from the standard locations

    if rshc-in-home '! grep -q -F -e "my/env/profile.sh" .profile'; then
        rshc-in-home '
            cat >> .profile <<-"EOF"
		
		# Include my customizations.
		. "${XDG_CONFIG_HOME:-$HOME/.config}"/my/env/profile.sh
		EOF
        '
    fi

    if rshc-in-home '! grep -q -F -e ".profile" .bash_profile'; then
        rshc-in-home '
            cat >> .bash_profile <<-"EOF"
		
		# For login shell, both interactive and non-.
		[ -f ~/.profile ] && source ~/.profile
		EOF
        '
    fi

    if rshc-in-home '! grep -q -F -e "my/bash/interactive/init.bash" .bashrc'; then
        rshc-in-home '
            cat >> .bashrc <<-"EOF"
		
		# Include my customizations.
		source "${XDG_CONFIG_HOME:-$HOME/.config}"/my/bash/interactive/init.bash
		EOF
        '
    fi

    if rshc-in-home '! grep -q -F -e ".bashrc" .bash_profile'; then
        rshc-in-home '
            cat >> .bash_profile <<-"EOF"
		
		# For interactive login shell.  (Non-interactive will do nothing.)
		[ -f ~/.bashrc ] && source ~/.bashrc
		EOF
        '
    fi

    # Stage any of the changes to ~/ resulting from the above.
    #
    stage-changes-in-home "after extending shell-init files" || true
}

function commit-staged-changes {
    vc=${gitVerbosity[commit]:-}

    rshc-in-home '
        export GIT_DIR=.dotfiles

        if git status --porcelain | grep -q -E -e "^A " ; then
            git commit '"$vc"' --message="Changes made by "'"${self@Q}"'"."
        else
            : # Nothing was added, so, to avoid error, do not try to commit.
        fi
    '
}


# Operations

process-vars
setup-home
setup-packages
setup-login
commit-staged-changes
