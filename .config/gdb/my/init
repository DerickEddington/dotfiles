define-prefix my
document my
My own namespace for my own commands.
end


# Create a temp dir, with a name determined by my GDB variable, that is
# exclusive to this instance of gdb, to avoid race conditions with the
# possibility of other instances.
#
# The primary use case for this is to support the technique of dynamically
# `source`ing a .gdb file that was generated by some user-defined GDB command to
# contain assignments of variables to values that capture the results of shell
# commands.  E.g.:
#   eval "shell echo \"set \\$fromOutside = $(/bin/foo --bar)\" \
#                 > /tmp/my-gdb-%u/foo.gdb", $myGDBtmpDirID
#   eval "source /tmp/my-gdb-%u/foo.gdb", $myGDBtmpDirID
#   eval "shell rm /tmp/my-gdb-%u/foo.gdb", $myGDBtmpDirID
#   print $fromOutside
#
set $myGDBtmpDirID = 0
while 1
  eval "shell mkdir /tmp/my-gdb-%u >& /dev/null", ++$myGDBtmpDirID
  if $_shell_exitcode == 0
    loop_break
  else
    if $myGDBtmpDirID % 100 == 0
      echo Warning: Trying to create my temp dir: Still looping!\n
    end
    if $myGDBtmpDirID > 10000
      echo Warning: Did not create my temp dir: Too many loops!\n
      loop_break
    end
  end
end

define hook-quit
  eval "shell rm -r -f /tmp/my-gdb-%u", $myGDBtmpDirID
end


define my sep-tty
  shell command -v noctty >& /dev/null
  if $_shell_exitcode == 0
    eval "shell xdg-terminal 'exec noctty > /tmp/my-gdb-%u/sep-tty.name'", $myGDBtmpDirID
    if $_shell_exitcode == 0
      eval "shell until [ -s /tmp/my-gdb-%u/sep-tty.name ]; do :; done", $myGDBtmpDirID
      eval "shell printf 'set inferior-tty %%s\\n' \"$(cat /tmp/my-gdb-%u/sep-tty.name)\" \
                    > /tmp/my-gdb-%u/sep-tty.gdb", $myGDBtmpDirID, $myGDBtmpDirID
      eval "source /tmp/my-gdb-%u/sep-tty.gdb", $myGDBtmpDirID
      eval "shell rm -f /tmp/my-gdb-%u/sep-tty.*", $myGDBtmpDirID
    else
      echo Warning: Failed invoking `xdg-terminal`.\n
    end
  else
    echo Warning: Failed. Missing utility `noctty`.\n
  end
end
document my sep-tty
Use a separate new terminal window as the tty for the program being debugged.
end


define my if_exited_normally_then_quit
  if $_isvoid($_exitsignal)
    if ! $_isvoid($_exitcode)
      quit $_exitcode
    end
  end
end
document my if_exited_normally_then_quit
Quit GDB with the program's exit-code,
if the program being debugged terminated normally;
else, the program crashed, so don't do anything, to allow GDB to remain for usage.

This can be especially useful when using GDB in a shell command (or GDB "command file").
E.g. to repeatedly run a program until it crashes:

  while
      gdb -ex "break $PANIC_FUNC" \ 
          -ex 'run' \ 
          -ex 'my if_exited_normally_then_quit' \ 
          -ex 'thread apply all backtrace' \ 
          -ex 'interrupt -a' \ 
          --args $PROG ${ARGS[@]}
  do
      echo; echo; date
  done

Such use of this command enables a shell command to continue when the $PROG exits with success,
without executing the other `-ex` commands that follow the `-ex 'my if_exited_normally_then_quit'`,
but also enables stopping in GDB if the $PROG crashes, with executing the other `-ex` commands,
so you may see the threads' backtraces and stop them all,
and so you may then use GDB interactively to investigate.
end


source-subinit my/cov
