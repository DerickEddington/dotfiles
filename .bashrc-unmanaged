# This file is executed for interactive Bash shells.

# If not running interactively, don't do anything
case $- in
    *i*) ;;
    *) return;;
esac


# Try to use newer bash version if the default one is ancient.
if [ ${BASH_VERSINFO[0]} -le 3  -a  $SHLVL -eq 1 ]
then
    # (The PLATFORM variable is defined in ~/.profile and is available here
    # because that file sources this one.)

    # If PLATFORM undefined, $HOME//... will be used.
    NEW_SH="$HOME/$PLATFORM/local/bin/bash"

    if [ -x "$NEW_SH" ]; then
        export SHELL="$NEW_SH"
        exec "$NEW_SH"
    fi
fi


# Execute the below when any bash is run, whether top-level or not.


# Shell options
shopt -s autocd
shopt -s cdspell
shopt -s checkhash
shopt -s checkjobs
shopt -s dirspell
#shopt -s dotglob
shopt -s extglob
# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize
# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
shopt -s globstar

# For the `time` builtin command.  Like the default but with the CPU% added.
TIMEFORMAT=$'\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS\nCPU%%\t%P'


# History
source ~/.bash_history.d/.bashrc


# My custom prompt.
if [ ${BASH_VERSINFO[0]} -ge 4 ]; then
    source ~/.bash_prompt
fi


# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.
if [ -f ~/.bash_aliases ]; then
    source ~/.bash_aliases
fi

# enable color support with aliases
if [ -n "$LS_COLORS" ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)"
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

alias ls='ls -CFhv --group-directories-first --quoting-style=c-maybe --color=tty'
alias l='ls -A -l'
alias ll='ls -l'
alias la='ls -A'
alias lla='ll -A'
alias lt='lla -t'
alias lr='lla -R'
alias ltr='lt -R'
alias lrt='lr -t'
alias rm="rm -i -r"
alias rmdir="rm -i -r"
alias pstree="pstree -a -l -n"
alias nano="nano -w"
alias ps="ps fxu"
alias df="df -h"
alias free='free -h'
alias objdump='objdump -M intel-mnemonic'
alias emacs='emacs --no-window-system'
alias root='sudo su -l'
alias sul='sudo su -l'
alias sshfs='sshfs -o reconnect -o workaround=all -o idmap=user -o follow_symlinks -o cache=yes -o cache_timeout=30 -o kernel_cache -o large_read'
alias unsshfs='fusermount -u'

function du {
    ( shopt -s dotglob
      if [ $# -ge 1 ]; then
          local ARGS=("$@")
      else
          local ARGS=(*)
      fi
      command du -s -c -h "${ARGS[@]}" | sort -h )
}

function nix-shell {
    local IS_INTERACTIVE=true IS_PURE=false GIVEN_COMMAND="" GIVEN_COMMAND_IDX=""

    # Scan the arguments to see what we're dealing with.
    local I ARGS=("$@")
    for ((I=0; I < ${#ARGS[@]}; I++)); do
        # (Note: This is imperfect and will misinterpret if these patterns are
        #  actually the value of some other option.)
        case "${ARGS[I]}" in
            (--command)
                GIVEN_COMMAND_IDX=$((I + 1))
                GIVEN_COMMAND="${ARGS[GIVEN_COMMAND_IDX]}"
                ;;
            (--run) IS_INTERACTIVE=false ;;
            (--pure) IS_PURE=true ;;
        esac
    done

    if $IS_PURE && $IS_INTERACTIVE; then
        # Use my custom history-file configuration and handling with `nix-shell
        # --pure`.  Also, prevent `nix-shell --pure` from clobbering the default
        # HISTFILE (which is an extra precaution redundantly in addition to
        # other sessions usually using ~/.bash_history.d/combined and
        # HISTFILE=$MY_SESSION_HISTFILE, just in case that is not in effect for
        # some reason).
        local MY_COMMAND=("source ~/.bash_history.d/.bashrc;")

        if [ "$GIVEN_COMMAND_IDX" ]; then
            # Allow the given command to control whether it does a "return".
            # This requires that it be placed at the end of MY_COMMAND.
            MY_COMMAND+=("$GIVEN_COMMAND")
            ARGS[GIVEN_COMMAND_IDX]="${MY_COMMAND[*]}"  # Replace the original.
        else
            MY_COMMAND+=("return")  # Drop into the interactive shell.
            ARGS=(--command "${MY_COMMAND[*]}" "${ARGS[@]}")
        fi

        command nix-shell "${ARGS[@]}"
    else
        command nix-shell "$@"  # Don't affect any of the arguments.
    fi
}


# Only execute this when a top-level bash is run.  I.e. not for any bash
# processes run as children of another bash.  This prevents things like repeated
# adding of the same value to PATH.
if [ $SHLVL -eq 1 ]; then
    :
fi
